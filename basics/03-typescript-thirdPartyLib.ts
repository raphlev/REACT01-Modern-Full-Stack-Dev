//Third-Party Libraries TypeScript, all by itself, is pretty great, but modern software is virtually never built with a language alone. 
//Almost certainly, you’ll want to bring in third-party libraries to help you along, and you most definitely can do that with TypeScript. 
//First, to state the obvious, you can use any of the JavaScript libraries you already know and love. Once your TypeScript is compiled down to JavaScript, 
//it neither knows nor cares what other JavaScript code you use. 
//But you can also bring in third-party TypeScript libraries, and that’s really what this section is talking about. 

//Most frequently, you’ll use NPM to import them into your project, the same as any other module you use from NPM. 
//Let’s say, for example, that you want to use the popular Lodash library in your code. First, you’ll need to install Lodash like any other NPM module: 
npm install --save lodash 
//But now, there’s an additional step: you must also import another related library: 
npm install --save-dev @types/lodash 
//This extra library is called a type declaration file, or a type binding file sometimes, 
//and it’s what tells TypeScript (tsc, more specifically) all about the types that Lodash uses and provides. 
//With that done, you can now use Lodash in your TypeScript code: 
import * as _ from "lodash"; 
_padStart("TypeScript + Lodash = COOL!", 10, "*"); 
//It’s that easy! What’s better is that because of that type declaration file, tsc (and your TypeScript dev tool of choice) knows about Lodash 
//in terms of TypeScript so that it can provide all the same warnings, errors, and IntelliSense, just like it does with your own code. 
//In NPM, most libraries that provide TypeScript bindings have a secondary library prefixed with @types, so you should look for those when choosing
// a library. Not all libraries offer them, of course, but that may well factor into your decisions about what libraries you use and which you don’t. 
//Caution One caveat to be aware of: if you use a library like this, you will almost certainly want to add an exclusion in tsconfig.json to skip 
//the node_modules directory. If you don’t do this, tsc will try to recompile any .ts file in it. 

//Debugging TypeScript Apps 
//Since TypeScript compiles down to JavaScript, you, of course, could debug the JavaScript directly with all the same 
//tooling you use at other times, be that browser dev tools or a full IDE of some sort. But that isn’t ideal because you aren’t debugging the code 
//you wrote, and that’s rarely something you want to do. Besides, the output JavaScript can look very different than the input TypeScript, 
//so it might be challenging to do even if you wanted to. 
//Given that TypeScript isn’t something that executes directly, that would seem to preclude the ability to use a debugger 
//to step through the code, or do any of the other things a debugger allows you to do. Sure, you can always revert to good ole’ console.log() debugging, 
//and sometimes that’s even easier than a full debugger, but most developers prefer having proper, purpose-made tooling, a debugger being one. 
//Fortunately, there is a solution available to allow you to use most of the same debugging tools as you do regular JavaScript, and it’s pretty simple: source maps. 

//SOURCE MAPS 
//A source map is an additional file that is generated by tsc when you append the --sourceMap option to it: 
tsc --sourceMap app.ts 
//With that option, you’ll find that alongside the app.js file that is produced, there will also now be an app.js.map file. 
//This file provides debugging tools with… wait for it… a map (bet you didn’t see that coming!) that correlates 
//the original TypeScript source to the generated JavaScript source. 
//It really is just that simple! 
//Wanna see what such a file looks like? Here you go: 
{  
    "version": 3,  
    "file": "app.js",  
    "sourceRoot": "",  
    "sources": [ "app.ts" ],  
    "names": [ ],  
    "mappings": "AAAA,SAAS,KAAK,CAAC,SAAiB;IAC9B,KAAK,CAAC,YAAU,SAAS,MAAG,CAAC,CAAC;AAChC,CAAC;AACD,KAAK,CAAC,gBAAgB,CAAC,CAAC" 
}
// Note that if you look at a real file it’s all on one line, but I’ve expanded it here to make it a bit easier to comprehend. 
//Now, to be clear, you really aren’t meant to look at this file yourself. The truth is it doesn’t make much sense to me either when you get to 
//the mappings property (though the rest is pretty obvious I’d say)! I’m sure I could go look up how this file works, but in the end, 
//it doesn’t matter. The tools know what to do with it, which is what matters. 
//Now, let’s go back in time to Chapter 5 and the example code there. Remember that, as shown in Figure 6-1?
//Figure 6-1 It’s a simple example, but it gets the job done – again! 
//To refresh your memory, here’s the code behind that wondrous display: 
function sayHi(humanName) {  alert("Hello, " + humanName + "!"); } 
sayHi("Luke Skywalker"); 
//# sourceMappingURL=app.js.map 
//Hey, wait a minute. That’s not the same as in Chapter 5! Indeed, that last line wasn’t there. 
//That’s the line that tells your tooling that a source map file exists and it’s something else the --source Map option does. With that in place, 
//the magic happens, as you can see in Figure 6-2.
//Figure 6-2 The magic of the source map line As you can see, Chrome dev tools sees that line, and as a result, it can even tell you that a source map 
//has been detected. If you look over on the left, you’ll see something else: there is now an app.ts file listed! Even though Chrome doesn’t speak TypeScript natively,
//that file is now available, and clicking it reveals what you see in Figure 6-3, which shouldn’t be at all surprising. 
// Figure 6-3 Hey, look, we have our original code! 
//Yep, we have our existing code now! Note, however, that for this to work, the app.ts file must be available. So, on a real web site, 
//you would need to deploy this file to your server as well as the final .js file. Therefore, this isn’t something you generally will want to do 
//on a production server. Source maps are a development tool, not a production support tool. 
//With access to the original source code, we can now use all the debugger goodness Chrome dev tools offers, including breakpoints, as you can see in Figure 6-4. 
// Figure 6-4 Using Chrome dev tools to debug TypeScript Execution has paused on the alert() line , and we can inspect variables, 
//step into the code, and do all the other things that a proper debugger allows. Pretty cool, right? 

//Summary 
//In this chapter, you learned about a few more TypeScript concepts, things that might be considered “advanced” (though that adjective is up for debate). 
//Things like interfaces, namespaces, modules, decorators, third-party library usage, and debugging with source maps were discussed. Between this chapter 
//and the previous one, you now have a solid foundation of TypeScript knowledge. 
//In the next chapter, we’ll look at one more tool that we’ll need in order to start building apps: Webpack.
